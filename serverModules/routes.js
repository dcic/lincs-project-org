
// module.exports 
module.exports = function(app) {
	var Todo = require("./models/todo");
	var express = require("express");
	var path = require("path");
	var fs = require("fs");  // file operations
	var validator = require("validator");
	var metaMarked = require("meta-marked");
	var toc = require("marked-toc");

	// Load story metadata into memory
	var stories = readMetaData("stories/");

	// Sort by recent stories
	stories = stories.sort(function(a, b) {
		// return new Date(b.date.split("-")) - new Date(a.date.split("-"));
		return new Date(b.date) - new Date(a.date);
	});

	// console.log(stories);



	// var assert = require("assert");
	// var glob = require("glob");

	// Data stored in memory

	var publications = require(path.join(__dirname, "../public/content/publications.json"))
	var centers = require(path.join(__dirname, "../public/content/centers.json"))

	// Express router (a sub Express application handling the HTTP API).
	var api_router = express.Router();

	// Middleware for all API requests
	api_router.use(function(request, response, next) {
		// console.log("API request");
		next();  // next API function in stack
	});

	// Register routes with the main application
	app.use("/api", api_router);

	// API requests
	api_router.get("/", function(request, response) {
		response.json({message: "hruray!"});
	});

	// Get requests for all todo items
	api_router.get("/todos", function(request, response) {
		Todo.find(function(error, elements) {
			if (error)
				response.send(error);
			response.json(elements);
		});
	});

	api_router.post("/todos", function(request, response) {
		console.log(request.body);

		Todo.create({
			text: request.body.text,
			done: false
		}, function(error, todo) {
			// create callback
			if (error)
				response.send(error);

			// Find all todo entries and return as json.
			Todo.find(function(error, todos) {
				if (error)
					response.send(error)
				response.json(todos);
			});
		});
	});

	api_router.get("/publications", function(request, response) {
		// response.sendFile(path.join(__dirname, "../public/content/publications.json"));
		response.json(publications);
	});

	api_router.get("/centers", function(request, response) {
		// response.sendFile(path.join(__dirname, "../public/content/centers.json"));
		response.json(centers);
	});

	api_router.get("/docs/articleDir/:entry", function(request, response) {
		// Interpret user input
		var entry_path = path.join(__dirname, "../public/docs", request.params.entry, "articles");

		// Validation of user input
		// Check if entry is specified
		if (validator.equals(request.params.entry, "")) {
			response.status(400).send({error: "Docs entry must be provided."});
			return;  // terminate response
		} 

		if (validator.equals(request.params.entry, "undefined")) {
			response.status(400).send({error: "Request for 'undefined' entry."});
			return;  // terminate response
		} 

		// All static tests passed
		// assert.equal(typeof(request.params.entry), "string");
		fs.readdir(entry_path, function(error, files) {
			// debugger;
			if (error) {
				response.status(404).send({error: "Entry does not exist."});
			} else {
				// filter for file extension
				response.json(files.filter(function(name) {
					return(path.extname(name) === ".md");
				}))
			}
		});
	});

	api_router.get("/articles", function(request, response) {
		response.send(stories);
	});

	// parses markdown files specified by path.
	// returns json object with meta fields (from front-matter YAML), html (generated from the markdown), and toc (table of content object).
	// TODO: id's generated by toc does not handle apostrophes the same wah as meta-marked.
	api_router.get("/parsemd/:mdpath(*)", function(request, response) {
 		// Read .md file
 		fs.readFile("public/" + request.params.mdpath, "utf8", function(error, data) {
 			if (error) {
 				response.status(404).send({error: "Entry does not exist."})
 			} else {
 				// var article = metaMarked(data, {sanitize: true});  // parse markdown for YAML metadata
 				var article = metaMarked(data);  // parse markdown for YAML metadata
 				article.toc = toc.raw(article.markdown, {allowedChars: "'"});  // generate table of content
 				delete article.markdown;  // remove markdown so as not to send it
 				response.json(article);  // containing fields meta, html, and toc
 			}
 		});
	});

	// app.get("/data-releases", function(request, response) {
	// 	response.redirect("#/data-releases");
	// })

	// Load single page application.
	// Wild card only applies after the above routes (order matters).
	app.get("*", function(request, response) {
		response.sendFile(path.join(__dirname, "../public/index.html"));
	});
}

// Read metadata from folder of md files with YAML metadata specification.
// Returns array of metadata sorted by the most recent entries.
var readMetaData = function(folder_path) {
	var fs = require("fs");
	var metaMarked = require("meta-marked");

	var meta_data = [];  // metadata sorted by date at last iteration
	// Loop over all files in stories folder
	try {
		fs.readdir("public/" + folder_path, function(error, files) {
			if (error)
				throw(error);
			// 
			files.forEach(function(file_name) {
				// Read file
				fs.readFile("public/" + folder_path + file_name, "utf8", function(error, data) {
					if (error) 
						throw(error);
					// Read article including metadata
					var article = metaMarked(data);

					// Guess url if not provided
					if (article.meta["url"] === undefined) {
						article.meta.url = folder_path + file_name.split(".")[0];
					}

					// Store meta data
					meta_data.push(article.meta);

					// Check if last element
					if (file_name === files[files.length - 1]) {
						// Sort metadata by recent date
						meta_data = meta_data.sort(function(a, b) {
							return new Date(b.date) - new Date(a.date);
						});
					}
				});
			});
		});
	} catch (error) {
		console.log("Error: ", error);
	}

	return meta_data;
}
